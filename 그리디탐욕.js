/* 
탐욕: 
가장 큰 동전을 많이 준다면 순간의 최적을 이용해서 답을 구할수 있음. -> 이것을 배수/약수 관계이기 때문에
가장 큰 동전을 많이줘도 또다른 최적이 존재

동전이 n종류 이고 무한히 잇다.
동전을 적절시 사용해 그가치의 합을 k로 만들려 할때 필요한 동전의 최솟값을 구해라.

10 4200
1,5,10,50,100,500,1000,5000,10000,50000

출력 : 6
*/
let N = 10;
let k = 4200;

let arr = [1,5,10,50,100,500,1000,5000,10000,50000];
let count = 0;
arr.reverse() // 탐욕이니까 큰것부터

arr.forEach(money => {
    while(k - money >= 0){
        k -= money;
        console.log(k,money)
        count++
    }
})

/* 
n개의 회의실의 시작시간,종료시간이 주어질때 
회의가 겹치지 않게하면서 회의를 할수있는 최대개수를 찾아보자.(회의의 시작시간과 끝나는 시간이 같으면 끝나자마자 시작하는것으로 간주)

-> 끝나는 시간이 빨라야 빨리 시작할수있음.
*/
let G = 11;
let arr4 = [
    [1,4],
    [3,5],
    [0,6],
    [5,7],
    [3,8],
    [5,9],
    [6,10],
    [8,11],
    [8,12],
    [2,13],
    [12,14],
]
// 회의를 정렬한다.
// 1. 먼저끝니는 회의 순서대로
// 2. 끝나는 순서가 같다면, 먼저 시작하는 외의 순서로
arr4.sort((a,b) => a[1] - b[1] || a[0] - b[0])

let count4 = 0;
let endTime = 0;

arr4.forEach(([start,end]) => {
    // 시작시간이 마친시간 보다 빠르면
    if(start < endTime){
        return
    }else{
        count4++
        endTime = end
    }
})

console.log(count4)
